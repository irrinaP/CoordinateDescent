using System;
using System.Windows.Forms;

namespace CoordinateDescentApp
{
    public partial class MainForm : Form
    {
        private TextBox textBoxX1;
        private TextBox textBoxX2;
        private Button optimizeButton;
        private TextBox resultTextBox;

        public MainForm()
        {
            InitializeComponent();
        }

        private void InitializeComponent()
        {
            this.textBoxX1 = new TextBox();
            this.textBoxX2 = new TextBox();
            this.optimizeButton = new Button();
            this.resultTextBox = new TextBox();
            this.SuspendLayout();

            // textBoxX1
            this.textBoxX1.Location = new System.Drawing.Point(12, 12);
            this.textBoxX1.Name = "textBoxX1";
            this.textBoxX1.Size = new System.Drawing.Size(100, 20);
            this.textBoxX1.TabIndex = 0;
            this.textBoxX1.Text = "1.0";

            // textBoxX2
            this.textBoxX2.Location = new System.Drawing.Point(118, 12);
            this.textBoxX2.Name = "textBoxX2";
            this.textBoxX2.Size = new System.Drawing.Size(100, 20);
            this.textBoxX2.TabIndex = 1;
            this.textBoxX2.Text = "1.0";

            // optimizeButton
            this.optimizeButton.Location = new System.Drawing.Point(12, 38);
            this.optimizeButton.Name = "optimizeButton";
            this.optimizeButton.Size = new System.Drawing.Size(206, 23);
            this.optimizeButton.TabIndex = 2;
            this.optimizeButton.Text = "Optimize";
            this.optimizeButton.UseVisualStyleBackColor = true;
            this.optimizeButton.Click += new System.EventHandler(this.optimizeButton_Click);

            // resultTextBox
            this.resultTextBox.Location = new System.Drawing.Point(12, 67);
            this.resultTextBox.Multiline = true;
            this.resultTextBox.Name = "resultTextBox";
            this.resultTextBox.ReadOnly = true;
            this.resultTextBox.Size = new System.Drawing.Size(206, 73);
            this.resultTextBox.TabIndex = 3;

            // MainForm
            this.ClientSize = new System.Drawing.Size(230, 150);
            this.Controls.Add(this.resultTextBox);
            this.Controls.Add(this.optimizeButton);
            this.Controls.Add(this.textBoxX2);
            this.Controls.Add(this.textBoxX1);
            this.Name = "MainForm";
            this.Text = "Coordinate Descent App";
            this.ResumeLayout(false);
        }

        private void optimizeButton_Click(object sender, EventArgs e)
        {
            // Чтение значений переменных из TextBox'ов
            double x1 = double.Parse(textBoxX1.Text);
            double x2 = double.Parse(textBoxX2.Text);

            // Пример функции, которую мы хотим оптимизировать
            Func<double[], double> targetFunction = x => x[0] * x[0] + x[1] * x[1];

            // Начальные значения переменных
            double[] initialGuess = { x1, x2 };

            // Задаем шаг спуска
            double stepSize = 0.1;

            // Задаем критерий останова (например, максимальное число итераций)
            int maxIterations = 100;

            // Запускаем метод покоординатного спуска
            double[] result = CoordinateDescentOptimization(targetFunction, initialGuess, stepSize, maxIterations);

            // Выводим результат в интерфейс
            resultTextBox.Text = $"Optimal solution: ({result[0]}, {result[1]})";
            resultTextBox.AppendText(Environment.NewLine);
            resultTextBox.AppendText($"Optimal value: {targetFunction(result)}");
        }

        private double[] CoordinateDescentOptimization(Func<double[], double> targetFunction, double[] initialGuess, double stepSize, int maxIterations)
        {
            double[] currentSolution = (double[])initialGuess.Clone();
            int n = initialGuess.Length;

            for (int iteration = 0; iteration < maxIterations; iteration++)
            {
                for (int i = 0; i < n; i++)
                {
                    // Вычисляем частную производную по i-й переменной
                    Func<double, double> partialDerivative = h => (targetFunction(UpdateVariable(currentSolution, i, h + stepSize)) - targetFunction(UpdateVariable(currentSolution, i, h))) / stepSize;

                    // Минимизируем функцию по i-й переменной
                    currentSolution[i] = Minimize(partialDerivative, currentSolution[i]);
                }
            }

            return currentSolution;
        }

        private double Minimize(Func<double, double> function, double initialGuess)
        {
            // Простая реализация метода золотого сечения для минимизации функции
            double a = initialGuess - 1.0;
            double b = initialGuess + 1.0;
            double epsilon = 1e-6;

            while (b - a > epsilon)
            {
                double x1 = b - (b - a) / 1.618;
                double x2 = a + (b - a) / 1.618;

                if (function(x1) < function(x2))
                    b = x2;
                else
                    a = x1;
            }

            return (a + b) / 2.0;
        }

        private double[] UpdateVariable(double[] vector, int index, double value)
        {
            double[] result = (double[])vector.Clone();
            result[index] = value;
            return result;
        }

        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }
    }
}
